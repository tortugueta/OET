#FIXME: Every time I execute createSceneWheel the drawing is resetted. This is
#	acceptable when I actually want to reset the scene, but when I change the
#	scale or invert the colors I don't want that. THIS STILL DOESN' WORK
#	PROPERLY. 
#FIXME: Jitter of the angle whenever I change any property of the wheel.
#FIXME: The File -> Quit menu action does not work in Windows
#FIXME: In Windows the records are written to file when I close the program. I
#	should add a function to immediately flush the data to file.

import sys
import math
import datetime
from PyQt4.QtCore import *
from PyQt4.QtGui import *
import main_window
import graphics_window

class MainWindow(QMainWindow, main_window.Ui_MainWindow):
	
	"""
	This is the main window of the program. The basic layout has been done in
	Qt Designer.
	"""
	
	def __init__(self, parent=None):
		QMainWindow.__init__(self, parent)
		main_window.Ui_MainWindow.__init__(self, parent)
		
		# Build the main window using the setupUi method generated by Qt
		# Designer
		self.setupUi(self)
		
		# Open the file where the records will be saved
		self.now = datetime.datetime.now()
		self.dateStr = '-'.join([str(self.now.year), str(self.now.month), str(self.now.day)])
		self.timeStr = ''.join(['%02d' % self.now.hour, '%02d' % self.now.minute,
			'%02d' % self.now.second])
		self.filename = '_'.join([self.dateStr, self.timeStr])
		self.filename = ''.join([self.filename, '.dat'])
		self.statusMsg = self.filename
		self.statusbar.showMessage(self.statusMsg)
		self.file = open(self.filename, 'a')
		
		# Write the header of the file
		scaleHead = 'Scale'
		thicknessHead = 'Thickness'
		angularVelocityHead = 'AngularVelocity (rps)'
		distanceHead = 'Distance (um)'
		densityHead = 'Density (g/cm3)'
		pradiusHead = 'Particle radius (um)'
		viscosityHead = 'Viscosity (mPa s)'
		linearVelocityHead = 'Linear velocity (um/s)'
		depHead = 'DEP (pN)'
		centripetalForceHead = 'Centripetal force (pN)'
		header = '\t'.join(['# '+scaleHead, thicknessHead, angularVelocityHead,
			distanceHead, densityHead, pradiusHead, viscosityHead,
			linearVelocityHead, depHead, centripetalForceHead])
		self.file.write(header + '\n\n')
		self.file.flush()

		# Here I define the brushes that will be used for the background and
		# foreground objects in the scene
		self.backgroundBrush = QBrush(Qt.black)
		self.foregroundBrush = QBrush(Qt.white)

		# A few initial values
		self.scale = self.scaleSpinBox.value()
		self.thickness = self.thicknessSpinBox.value()
		self.angularVelocity = self.speedSpinBox.value()
		self.distance = self.distanceSpinBox.value()
		self.density = self.densitySpinBox.value()
		self.pradius = self.pradiusSpinBox.value()
		self.viscosity = self.viscositySpinBox.value()
		self.updateCalculations()
		self.angle = 0.0
		
		
		# Define the basic variables for the rotation
		self.timeunit = 0.1
		self.timer = QTimeLine(self.timeunit * 1000)
		self.timer.setFrameRange(0, 1)
		self.timer.setUpdateInterval(1)
		self.timer.setCurveShape(3)
		self.rotation = QGraphicsItemAnimation()
		self.rotation.setTimeLine(self.timer)

		# Create the dialog that will show the graphics window
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		self.createSceneWheel()

		# Connections
		self.connect(self.actionInvert, SIGNAL("toggled(bool)"),
			self.switchColor)
		self.connect(self.scaleSpinBox, SIGNAL("valueChanged(double)"), 
			self.setScale)
		self.connect(self.thicknessSpinBox, SIGNAL("valueChanged(double)"), 
			self.setThickness)
		self.connect(self.speedSpinBox, SIGNAL("valueChanged(double)"), 
			self.setAngularVelocity)
		self.connect(self.distanceSpinBox, SIGNAL("valueChanged(double)"), 
			self.setDistance)
		self.connect(self.densitySpinBox, SIGNAL("valueChanged(double)"), 
			self.setDensity)
		self.connect(self.pradiusSpinBox, SIGNAL("valueChanged(double)"), 
			self.setPRadius)
		self.connect(self.viscositySpinBox, SIGNAL("valueChanged(double)"), 
			self.setViscosity)
		self.connect(self.engagePushButton, SIGNAL("clicked()"), self.rotate)
		self.connect(self.timer, SIGNAL("finished()"), self.rotate)
		self.connect(self.stopPushButton, SIGNAL("clicked()"), self.stopTimer)
		self.connect(self.resetPushButton,  SIGNAL("clicked()"), self.reset)
		self.connect(self.recordPushButton, SIGNAL("clicked()"), self.record)
		self.connect(self,  SIGNAL("destroyed()"), self.file.close)

	def createSceneWheel(self):
		"""
		This function creates the figures and adds them to the scene
		"""

		# Here we add the graphics scene. The graphicsView has been created
		# during setupUi
		self.scene = DiagramScene(self.backgroundBrush, parent=self)
		self.graphWin.graphicsView.setScene(self.scene)

		# Create the items
		self.vline = VerticalLine(0, -50+self.thickness/2, 100-self.thickness,
			self.thickness,
			self.foregroundBrush)
		self.hline = HorizontalLine(-50+self.thickness/2, 0, 100-self.thickness,
			self.thickness,
			self.foregroundBrush)
		self.circle = Circle(0, 0, 50, self.thickness, self.foregroundBrush)
		self.wheel = QGraphicsItemGroup()
		self.scene.addItem(self.wheel)
		
		self.wheel.addToGroup(self.vline)
		self.wheel.addToGroup(self.hline)
		self.wheel.addToGroup(self.circle)
		
		# Set the scale and rotation
		self.wheel.setScale(self.scale)
		self.wheel.setRotation(self.angle)		
		
		# Add the item to the rotation animation
		self.rotation.setItem(self.wheel)

	
	def rotate(self):
		"""
		Execute a rotation at speed revolutions per second
		"""
		
		self.rotation.setRotationAt(0, self.angle)
		self.rotation.setRotationAt(1, 
			self.angle + self.angularVelocity * 360 * self.timeunit)
		self.angle += self.angularVelocity * 360 * self.timeunit
		if self.angle >= 360:
			self.angle -= 360
		self.timer.start()

	def setAngularVelocity(self, angularVelocity):
		"""
		Set the speed of the rotation in revolutions per second
		"""
		
		self.angularVelocity = angularVelocity
		self.updateCalculations()

	def switchColor(self, selected):
		"""
		If the "invert" option is selected, switch to black on white.
		"""
		
		if selected:
			self.backgroundBrush = QBrush(Qt.white)
			self.foregroundBrush = QBrush(Qt.black)
		else:
			self.backgroundBrush = QBrush(Qt.black)
			self.foregroundBrush = QBrush(Qt.white)
		
		self.createSceneWheel()
	
	def setScale(self, scale):
		"""
		Change the scale of the scene
		"""
		
		self.scale = scale
		self.createSceneWheel()
	
	def setThickness(self, thickness):
		"""
		Change the thickness of the lines
		"""
		
		self.thickness = thickness
		self.createSceneWheel()
	
	def reset(self):
		"""
		Reset the scene to the initial value
		"""

		self.graphWin.close()
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		self.angle = 0
		self.createSceneWheel()
				
	def stopTimer(self):
		"""
		Stop the animation
		"""
		
		self.timer.stop()
		
	def setDistance(self, distance):
		"""
		Change the distance where the bead is located from the center of the
		wheel
		"""
		
		self.distance = distance
		self.updateCalculations()
		
	def setDensity(self, density):
		"""
		Change the density of the particle
		"""
		
		self.density = density
		self.updateCalculations()
		
	def setPRadius(self, radius):
		"""
		Set the radius of the particle
		"""
		
		self.pradius = radius
		self.updateCalculations()
		
	def setViscosity(self, viscosity):
		"""
		Set the viscosity of the fluid
		"""
		
		self.viscosity = viscosity
		self.updateCalculations()
		
	def updateCalculations(self):
		"""
		Update the calculated value of the linear speed.
		"""
		
		# Calculate the linear velocity. Convert rps to rad/s
		self.angularVelocitySI = self.angularVelocity * 2 * math.pi			 # From rps to rad/s
		self.linearVelocity = self.angularVelocitySI * self.distance		 # In um/s
		self.linVelocityLcdNumber.display(self.linearVelocity)
		
		# Calculate the DEP, which, at constant velocity, will be exactly the
		# same as the drag force. Pay attention to the units.
		self.viscositySI = self.viscosity * 1e-3                             # From mPa s to Pa s
		self.pradiusSI = self.pradius * 1e-6                                 # From um to m
		self.linearVelocitySI = self.linearVelocity * 1e-6                   # From um/s to m/s
		self.depSI = 6 * math.pi * self.viscositySI * self.pradiusSI * \
			self.linearVelocitySI											 # In N
		self.dep = self.depSI * 1e12										 # From N to pN
		self.forceLcdNumber.display(self.dep)                       		 # In pN
		
		# Calculate the centripetal force. Attention to the units
		self.distanceSI = self.distance * 1e-6								 # From um to m
		self.densitySI = self.density * 1e3                                  # From g/cm3 to Kg/m3
		self.beadVolumeSI = 4 * math.pi * self.pradiusSI**3 / 3				 # In m3
		self.beadMassSI = self.densitySI * self.beadVolumeSI				 # In Kg
		self.centripetalForceSI = self.beadMassSI * \
			self.angularVelocitySI**2 * self.distanceSI						 # In N
		self.centripetalForce = self.centripetalForceSI * 1e12				 # From N to pN
		self.centripetalLcdNumber.display(self.centripetalForce)        	 # In pN

	def record(self):
		"""
		Save the current parameters to the currently open file
		"""
		
		scale = str(self.scale)
		thickness = str(self.thickness)
		angularVelocity = str(self.angularVelocity)		# rps
		distance = str(self.distance)					# um
		density = str(self.density)						# g/cm3
		pradius = str(self.pradius)						# um
		viscosity = str(self.viscosity)					# mPa s
		linearVelocity = str(self.linearVelocity)		# um/s
		dep = str(self.dep)								# pN
		centripetalForce = str(self.centripetalForce)	# pN
		
		recordLine = '\t'.join([scale, thickness, angularVelocity, distance,
			density, pradius, viscosity, linearVelocity, dep,
			centripetalForce])
		self.file.write(recordLine + '\n')
		self.file.flush()
		

class GraphicsWindow(QDialog, graphics_window.Ui_GraphicsWindow):
	"""
	This is the dialog that shows the graphics window
	"""
	
	def __init__(self, parent=None):
		QDialog.__init__(self, parent)
		graphics_window.Ui_GraphicsWindow.__init__(self, parent)
		
		# Build the main window using the setupUi method generated by Qt
		# Designer
		self.setupUi(self)


class DiagramScene(QGraphicsScene):
	"""
	This is a subclass of a QGraphicsScene. We can set the color of the
	background during instantiation by supplying a brush of the desired color.
	"""
	
	def __init__(self, brush, parent=None):
		QGraphicsScene.__init__(self, parent)
		
		self.setBackgroundBrush(brush)


class VerticalLine(QGraphicsLineItem):
	"""
	This is a subclass of QGraphicsLineItem that draws a vertical line.
	The constructor expects the coordinates of the initial point as well as the
	length and width of the line. The color is set through the brush that we
	supply to the constructor.
	"""
	
	def __init__(self, x0, y0, length, width, brush, parent=None):
		QGraphicsLineItem.__init__(self, parent)

		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)
		self.setLine(x0, y0, x0, y0+length)


class HorizontalLine(QGraphicsLineItem):
	"""
	This is a subclass of QGraphicsLineItem that draws a horizontal line.
	The constructor expects the coordinates of the initial point as well as the
	length and width of the line. The color is set through the brush that we
	supply to the constructor.
	"""
	
	def __init__(self, x0, y0, length, width, brush, parent=None):
		QGraphicsLineItem.__init__(self, parent)
		
		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)
		self.setLine(x0, y0, x0+length, y0)


class Circle(QGraphicsEllipseItem):
	"""
	This is a subclass of the more general ellipse shape. We should supply
	the coordinates of the center as well as the radius and the width of the
	line used to draw the circle. The color is set through the brush.
	"""
	
	def __init__(self, x0, y0, radius, width, brush, parent=None):
		QGraphicsEllipseItem.__init__(self, parent)
		
		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)		
		self.setRect(x0-radius, y0-radius, 2*radius, 2*radius)


def main():
	app = QApplication(sys.argv)
	mainWin = MainWindow()
	mainWin.show()
	app.exec_()

main()
