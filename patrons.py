#FIXME: Every time I execute createSceneWheel the drawing is resetted. This is
#	acceptable when I actually want to reset the scene, but when I change the
#	scale or invert the colors I don't want that. THIS STILL DOESN' WORK
#	PROPERLY. 
#FIXME: Jitter of the angle whenever I change any property of the wheel.
#TODO: The reset button should recreate the graphics dialog if it has been killed

import sys
import math
from PyQt4.QtCore import *
from PyQt4.QtGui import *
import main_window
import graphics_window

class MainWindow(QMainWindow, main_window.Ui_MainWindow):
	
	"""
	This is the main window of the program. The basic layout has been done in
	Qt Designer.
	"""
	
	def __init__(self, parent=None):
		QMainWindow.__init__(self, parent)
		main_window.Ui_MainWindow.__init__(self, parent)
		
		# Build the main window using the setupUi method generated by Qt
		# Designer
		self.setupUi(self)
		self.msg_stopped = 'Press the "Engage" button to boldly go where ' + \
			'no man has gone before ("Reset" to reset the figure)'
		self.msg_running = 'Press the "Stop" button to stop the animation'
		self.statusbar.showMessage(self.msg_stopped)
		
		# Here I define the brushes that will be used for the background and
		# foreground objects in the scene
		self.backgroundBrush = QBrush(Qt.black)
		self.foregroundBrush = QBrush(Qt.white)

		# A few initial values
		self.scale = self.scaleSpinBox.value()
		self.thickness = self.thicknessSpinBox.value()
		self.angularVelocity = self.speedSpinBox.value()
		self.distance = self.distanceSpinBox.value()
		self.viscosity = self.viscositySpinBox.value()
		self.pradius = self.pradiusSpinBox.value()
		self.updateCalculations()
		self.angle = 0.0
		
		
		# Define the basic variables for the rotation
		self.timeunit = 0.1
		self.timer = QTimeLine(self.timeunit * 1000)
		self.timer.setFrameRange(0, 1)
		self.timer.setUpdateInterval(1)
		self.timer.setCurveShape(3)
		self.rotation = QGraphicsItemAnimation()
		self.rotation.setTimeLine(self.timer)

		# Create the dialog that will show the graphics window
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		self.createSceneWheel()

		# Connections
		self.connect(self.actionInvert, SIGNAL("toggled(bool)"),
			self.switchColor)
		self.connect(self.scaleSpinBox, SIGNAL("valueChanged(double)"), 
			self.setScale)
		self.connect(self.thicknessSpinBox, SIGNAL("valueChanged(double)"), 
			self.setThickness)
		self.connect(self.speedSpinBox, SIGNAL("valueChanged(double)"), 
			self.setAngularVelocity)
		self.connect(self.distanceSpinBox, SIGNAL("valueChanged(double)"), 
			self.setDistance)
		self.connect(self.pradiusSpinBox, SIGNAL("valueChanged(double)"), 
			self.setPRadius)
		self.connect(self.viscositySpinBox, SIGNAL("valueChanged(double)"), 
			self.setViscosity)
		self.connect(self.engagePushButton, SIGNAL("clicked()"), self.rotate)
		self.connect(self.timer, SIGNAL("finished()"), self.rotate)
		self.connect(self.stopPushButton, SIGNAL("clicked()"), self.stopTimer)
		self.connect(self.resetPushButton,  SIGNAL("clicked()"), self.reset)

	def createSceneWheel(self):
		"""
		This function creates the figures and adds them to the scene
		"""

		# Here we add the graphics scene. The graphicsView has been created
		# during setupUi
		self.scene = DiagramScene(self.backgroundBrush, parent=self)
		self.graphWin.graphicsView.setScene(self.scene)

		# Create the items
		self.vline = VerticalLine(0, -50+self.thickness/2, 100-self.thickness,
			self.thickness,
			self.foregroundBrush)
		self.hline = HorizontalLine(-50+self.thickness/2, 0, 100-self.thickness,
			self.thickness,
			self.foregroundBrush)
		self.circle = Circle(0, 0, 50, self.thickness, self.foregroundBrush)
		self.wheel = QGraphicsItemGroup()
		self.scene.addItem(self.wheel)
		
		self.wheel.addToGroup(self.vline)
		self.wheel.addToGroup(self.hline)
		self.wheel.addToGroup(self.circle)
		
		# Set the scale and rotation
		self.wheel.setScale(self.scale)
		self.wheel.setRotation(self.angle)		
		
		# Add the item to the rotation animation
		self.rotation.setItem(self.wheel)

	
	def rotate(self):
		"""
		Execute a rotation at speed revolutions per second
		"""
		
		self.statusbar.showMessage(self.msg_running)
		self.rotation.setRotationAt(0, self.angle)
		self.rotation.setRotationAt(1, 
			self.angle + self.angularVelocity * 360 * self.timeunit)
		self.angle += self.angularVelocity * 360 * self.timeunit
		if self.angle >= 360:
			self.angle -= 360
		self.timer.start()

	def setAngularVelocity(self, angularVelocity):
		"""
		Set the speed of the rotation in revolutions per second
		"""
		
		self.angularVelocity = angularVelocity
		self.updateCalculations()

	def switchColor(self, selected):
		"""
		If the "invert" option is selected, switch to black on white.
		"""
		
		if selected:
			self.backgroundBrush = QBrush(Qt.white)
			self.foregroundBrush = QBrush(Qt.black)
		else:
			self.backgroundBrush = QBrush(Qt.black)
			self.foregroundBrush = QBrush(Qt.white)
		
		self.createSceneWheel()
	
	def setScale(self, scale):
		"""
		Change the scale of the scene
		"""
		
		self.scale = scale
		self.createSceneWheel()
	
	def setThickness(self, thickness):
		"""
		Change the thickness of the lines
		"""
		
		self.thickness = thickness
		self.createSceneWheel()
	
	def reset(self):
		"""
		Reset the scene to the initial value
		"""

		self.graphWin.close()
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		self.angle = 0
		self.createSceneWheel()
				
	def stopTimer(self):
		"""
		Stop the animation
		"""
		
		self.timer.stop()
		self.statusbar.showMessage(self.msg_stopped)
		
	def setDistance(self, distance):
		"""
		Change the distance where the bead is located from the center of the
		wheel
		"""
		
		self.distance = distance
		self.updateCalculations()
		
	def setPRadius(self, radius):
		"""
		Set the radius of the particle
		"""
		
		self.pradius = radius
		self.updateCalculations()
		
	def setViscosity(self, viscosity):
		"""
		Set the viscosity of the fluid
		"""
		
		self.viscosity = viscosity
		self.updateCalculations()
		
	def updateCalculations(self):
		"""
		Update the calculated value of the linear speed.
		"""
		
		# Calculate the linear velocity. Convert rps to rad/s
		self.linearVelocity = self.angularVelocity * 2 * math.pi * self.distance
		self.linVelocityLcdNumber.display(self.linearVelocity)
		
		# Calculate the DEP, which, at constant velocity, will be exactly the
		# same as the drag force. Pay attention to the units.
		self.viscositySI = self.viscosity * 1e-3
		self.pradiusSI = self.pradius * 1e-6
		self.linearVelocitySI = self.linearVelocity * 1e-6
		self.depSI = 6 * math.pi * self.viscositySI * self.pradiusSI * \
			self.linearVelocitySI
		self.forceLcdNumber.display(self.depSI * 1e12)		


class GraphicsWindow(QDialog, graphics_window.Ui_GraphicsWindow):
	"""
	This is the dialog that shows the graphics window
	"""
	
	def __init__(self, parent=None):
		QDialog.__init__(self, parent)
		graphics_window.Ui_GraphicsWindow.__init__(self, parent)
		
		# Build the main window using the setupUi method generated by Qt
		# Designer
		self.setupUi(self)


class DiagramScene(QGraphicsScene):
	"""
	This is a subclass of a QGraphicsScene. We can set the color of the
	background during instantiation by supplying a brush of the desired color.
	"""
	
	def __init__(self, brush, parent=None):
		QGraphicsScene.__init__(self, parent)
		
		self.setBackgroundBrush(brush)


class VerticalLine(QGraphicsLineItem):
	"""
	This is a subclass of QGraphicsLineItem that draws a vertical line.
	The constructor expects the coordinates of the initial point as well as the
	length and width of the line. The color is set through the brush that we
	supply to the constructor.
	"""
	
	def __init__(self, x0, y0, length, width, brush, parent=None):
		QGraphicsLineItem.__init__(self, parent)

		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)
		self.setLine(x0, y0, x0, y0+length)


class HorizontalLine(QGraphicsLineItem):
	"""
	This is a subclass of QGraphicsLineItem that draws a horizontal line.
	The constructor expects the coordinates of the initial point as well as the
	length and width of the line. The color is set through the brush that we
	supply to the constructor.
	"""
	
	def __init__(self, x0, y0, length, width, brush, parent=None):
		QGraphicsLineItem.__init__(self, parent)
		
		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)
		self.setLine(x0, y0, x0+length, y0)


class Circle(QGraphicsEllipseItem):
	"""
	This is a subclass of the more general ellipse shape. We should supply
	the coordinates of the center as well as the radius and the width of the
	line used to draw the circle. The color is set through the brush.
	"""
	
	def __init__(self, x0, y0, radius, width, brush, parent=None):
		QGraphicsEllipseItem.__init__(self, parent)
		
		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)		
		self.setRect(x0-radius, y0-radius, 2*radius, 2*radius)


def main():
	app = QApplication(sys.argv)
	mainWin = MainWindow()
	mainWin.show()
	app.exec_()

main()
