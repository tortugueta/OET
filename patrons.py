#FIXME: Jitter of the angle whenever I change any property of the wheel.
#FIXME: The File -> Quit menu action does not work in Windows and I don't see
#	why
#FIXME: When I switch tabs and come back to The Wheel, starting the animation
#	gives a QTimeLine::start: already running message, regardless of wether I
#	have previously started or not. I don't see where this is coming from.
#TODO: Add error calculation
#TODO: Add tabs, one for every test. Activating one tab should create the
#	corresponding graphics window

import sys
import math
import datetime
from PyQt4.QtCore import *
from PyQt4.QtGui import *
import main_window
import graphics_window

class MainWindow(QMainWindow, main_window.Ui_MainWindow):
	
	"""
	This is the main window of the program. The basic layout has been done in
	Qt Designer.
	"""
	
	def __init__(self, parent=None):
		QMainWindow.__init__(self, parent)
		main_window.Ui_MainWindow.__init__(self, parent)
		
		# Build the main window using the setupUi method generated by Qt
		# Designer
		self.setupUi(self)
		
		# Open the file where the records will be saved
		self.now = datetime.datetime.now()
		self.dateStr = '-'.join([str(self.now.year), str(self.now.month),
			str(self.now.day)])
		self.timeStr = ''.join(['%02d' % self.now.hour,
			'%02d' % self.now.minute, '%02d' % self.now.second])
		self.filename = '_'.join([self.dateStr, self.timeStr])
		self.filename = ''.join([self.filename, '.dat'])
		self.statusMsg = self.filename
		self.statusbar.showMessage(self.statusMsg)
		self.file = open(self.filename, 'a')
		
		# Here I define the brushes that will be used for the background and
		# foreground objects in the scenes. This is common to all scenes.
		self.backgroundBrush = QBrush(Qt.black)
		self.foregroundBrush = QBrush(Qt.white)

		# Create the dialog that will show the graphics window
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		
		# By default start with the wheel
		self.TheWheel()

		# Global connections
		self.connect(self.actionInvert, SIGNAL("toggled(bool)"),
			self.switchColor)
		self.connect(self,  SIGNAL("destroyed()"), self.file.close)
		self.connect(self.tabWidget, SIGNAL("currentChanged(int)"), 
			self.switchTab)
	
	def switchTab(self, index):
		"""
		What to do when the tab is switched
		"""
		
		self.graphWin.close()
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		
		if index == 0:
			self.TheWheel()
		if index == 1:
			self.Test2()
	
	def switchColor(self, selected):
		"""
		If the "invert" option is selected, switch to black on white.
		"""
		
		if selected:
			self.backgroundBrush = QBrush(Qt.white)
			self.foregroundBrush = QBrush(Qt.black)
		else:
			self.backgroundBrush = QBrush(Qt.black)
			self.foregroundBrush = QBrush(Qt.white)
		
		if self.currentTest == 'The Wheel':
			self.wheel_createSceneWheel()

	def TheWheel(self):
		"""
		This code runs the Wheel test
		"""
		
		# Write the header of the file for this particular test
		scaleHead = 'Scale'
		thicknessHead = 'Thickness'
		angularVelocityHead = 'AngularVelocity (rps)'
		distanceHead = 'Distance (um)'
		densityHead = 'Density (g/cm3)'
		pradiusHead = 'Particle radius (um)'
		viscosityHead = 'Viscosity (mPa s)'
		linearVelocityHead = 'Linear velocity (um/s)'
		depHead = 'DEP (pN)'
		centripetalForceHead = 'Centripetal force (pN)'
		header = '\t'.join(['# '+scaleHead, thicknessHead, angularVelocityHead,
			distanceHead, densityHead, pradiusHead, viscosityHead,
			linearVelocityHead, depHead, centripetalForceHead])
		self.file.write('# The Wheel test')
		self.file.write(header + '\n\n')
		self.file.flush()
		
		# A few initial values
		self.wheel_scale = self.scaleSpinBox.value()
		self.wheel_thickness = self.thicknessSpinBox.value()
		self.wheel_angularVelocity = self.speedSpinBox.value()
		self.wheel_distance = self.distanceSpinBox.value()
		self.wheel_density = self.densitySpinBox.value()
		self.wheel_pradius = self.pradiusSpinBox.value()
		self.wheel_viscosity = self.viscositySpinBox.value()
		self.wheel_updateCalculations()
		self.wheel_angle = 0.0
		
		# Define the basic variables for the rotation
		self.wheel_timeunit = 0.1
		self.wheel_timer = QTimeLine(self.wheel_timeunit * 1000)
		self.wheel_timer.setFrameRange(0, 1)
		self.wheel_timer.setUpdateInterval(1)
		self.wheel_timer.setCurveShape(3)
		self.wheel_rotation = QGraphicsItemAnimation()
		self.wheel_rotation.setTimeLine(self.wheel_timer)
		
		# Create the scene
		self.wheel_createSceneWheel()
		
		# Connections specific to The Wheel
		self.connect(self.scaleSpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setScale)
		self.connect(self.thicknessSpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setThickness)
		self.connect(self.speedSpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setAngularVelocity)
		self.connect(self.distanceSpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setDistance)
		self.connect(self.densitySpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setDensity)
		self.connect(self.pradiusSpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setPRadius)
		self.connect(self.viscositySpinBox, SIGNAL("valueChanged(double)"), 
			self.wheel_setViscosity)
		self.connect(self.engagePushButton, SIGNAL("clicked()"), self.wheel_rotate)
		self.connect(self.wheel_timer, SIGNAL("finished()"), self.wheel_rotate)
		self.connect(self.stopPushButton, SIGNAL("clicked()"), self.wheel_stopTimer)
		self.connect(self.resetPushButton,  SIGNAL("clicked()"), self.wheel_reset)
		self.connect(self.recordPushButton, SIGNAL("clicked()"), self.wheel_record)

	def wheel_createSceneWheel(self):
		"""
		This function creates the figures and adds them to the scene
		"""

		# Here we add the graphics scene. The graphicsView has been created
		# during setupUi
		self.scene = DiagramScene(self.backgroundBrush, parent=self)
		self.graphWin.graphicsView.setScene(self.scene)

		# Create the items
		self.vline = VerticalLine(0, -50+self.wheel_thickness/2,
			100-self.wheel_thickness, self.wheel_thickness,
			self.foregroundBrush)
		self.hline = HorizontalLine(-50+self.wheel_thickness/2, 0,
			100-self.wheel_thickness, self.wheel_thickness,
			self.foregroundBrush)
		self.circle = Circle(0, 0, 50, self.wheel_thickness,
			self.foregroundBrush)
		self.wheel = QGraphicsItemGroup()
		self.scene.addItem(self.wheel)
		
		self.wheel.addToGroup(self.vline)
		self.wheel.addToGroup(self.hline)
		self.wheel.addToGroup(self.circle)
		
		# Set the scale and rotation
		self.wheel.setScale(self.wheel_scale)
		self.wheel.setRotation(self.wheel_angle)		
		
		# Add the item to the rotation animation
		self.wheel_rotation.setItem(self.wheel)

	
	def wheel_rotate(self):
		"""
		Execute a rotation at speed revolutions per second
		"""
		
		self.wheel_rotation.setRotationAt(0, self.wheel_angle)
		self.wheel_rotation.setRotationAt(1, 
			self.wheel_angle + self.wheel_angularVelocity * 360 * self.wheel_timeunit)
		self.wheel_angle += self.wheel_angularVelocity * 360 * self.wheel_timeunit
		if self.wheel_angle >= 360:
			self.wheel_angle -= 360
		self.wheel_timer.start()

	def wheel_setAngularVelocity(self, angularVelocity):
		"""
		Set the speed of the rotation in revolutions per second
		"""
		
		self.wheel_angularVelocity = angularVelocity
		self.wheel_updateCalculations()
	
	def wheel_setScale(self, scale):
		"""
		Change the scale of the scene
		"""
		
		self.wheel_scale = scale
		self.wheel_createSceneWheel()
	
	def wheel_setThickness(self, thickness):
		"""
		Change the thickness of the lines
		"""
		
		self.wheel_thickness = thickness
		self.wheel_createSceneWheel()
	
	def wheel_reset(self):
		"""
		Reset the scene to the initial value
		"""

		self.graphWin.close()
		self.graphWin = GraphicsWindow(parent=self)
		self.graphWin.show()
		self.wheel_angle = 0
		self.wheel_createSceneWheel()
				
	def wheel_stopTimer(self):
		"""
		Stop the animation
		"""
		
		self.wheel_timer.stop()
		
	def wheel_setDistance(self, distance):
		"""
		Change the distance where the bead is located from the center of the
		wheel
		"""
		
		self.wheel_distance = distance
		self.wheel_updateCalculations()
		
	def wheel_setDensity(self, density):
		"""
		Change the density of the particle
		"""
		
		self.wheel_density = density
		self.wheel_updateCalculations()
		
	def wheel_setPRadius(self, radius):
		"""
		Set the radius of the particle
		"""
		
		self.wheel_pradius = radius
		self.wheel_updateCalculations()
		
	def wheel_setViscosity(self, viscosity):
		"""
		Set the viscosity of the fluid
		"""
		
		self.wheel_viscosity = viscosity
		self.wheel_updateCalculations()
		
	def wheel_updateCalculations(self):
		"""
		Update the calculated values of the Wheel test
		"""
		
		# Calculate the linear velocity. Convert rps to rad/s
		self.angularVelocitySI = self.wheel_angularVelocity * 2 * math.pi	 # From rps to rad/s
		self.linearVelocity = self.angularVelocitySI * self.wheel_distance	 # In um/s
		self.linVelocityLcdNumber.display(self.linearVelocity)
		
		# Calculate the DEP, which, at constant velocity, will be exactly the
		# same as the drag force. Pay attention to the units.
		self.viscositySI = self.wheel_viscosity * 1e-3                             # From mPa s to Pa s
		self.pradiusSI = self.wheel_pradius * 1e-6                           # From um to m
		self.linearVelocitySI = self.linearVelocity * 1e-6                   # From um/s to m/s
		self.depSI = 6 * math.pi * self.viscositySI * self.pradiusSI * \
			self.linearVelocitySI											 # In N
		self.dep = self.depSI * 1e12										 # From N to pN
		self.forceLcdNumber.display(self.dep)                       		 # In pN
		
		# Calculate the centripetal force. Attention to the units
		self.distanceSI = self.wheel_distance * 1e-6						 # From um to m
		self.densitySI = self.wheel_density * 1e3                            # From g/cm3 to Kg/m3
		self.beadVolumeSI = 4 * math.pi * self.pradiusSI**3 / 3				 # In m3
		self.beadMassSI = self.densitySI * self.beadVolumeSI				 # In Kg
		self.centripetalForceSI = self.beadMassSI * \
			self.angularVelocitySI**2 * self.distanceSI						 # In N
		self.centripetalForce = self.centripetalForceSI * 1e12				 # From N to pN
		self.centripetalLcdNumber.display(self.centripetalForce)        	 # In pN

	def wheel_record(self):
		"""
		Save the current parameters to the currently open file
		"""
		
		scale = str(self.wheel_scale)
		thickness = str(self.wheel_thickness)
		angularVelocity = str(self.wheel_angularVelocity)	# rps
		distance = str(self.wheel_distance)					# um
		density = str(self.wheel_density)					# g/cm3
		pradius = str(self.wheel_pradius)					# um
		viscosity = str(self.wheel_viscosity)				# mPa s
		linearVelocity = str(self.linearVelocity)			# um/s
		dep = str(self.dep)									# pN
		centripetalForce = str(self.centripetalForce)		# pN
		
		recordLine = '\t'.join([scale, thickness, angularVelocity, distance,
			density, pradius, viscosity, linearVelocity, dep,
			centripetalForce])
		self.file.write(recordLine + '\n')
		self.file.flush()
	
	def Test2(self):
		"""
		This is a placeholder for a future second test added to the program
		"""
		
		pass
		

class GraphicsWindow(QDialog, graphics_window.Ui_GraphicsWindow):
	"""
	This is the dialog that shows the graphics window
	"""
	
	def __init__(self, parent=None):
		QDialog.__init__(self, parent)
		graphics_window.Ui_GraphicsWindow.__init__(self, parent)
		
		# Build the main window using the setupUi method generated by Qt
		# Designer
		self.setupUi(self)


class DiagramScene(QGraphicsScene):
	"""
	This is a subclass of a QGraphicsScene. We can set the color of the
	background during instantiation by supplying a brush of the desired color.
	"""
	
	def __init__(self, brush, parent=None):
		QGraphicsScene.__init__(self, parent)
		
		self.setBackgroundBrush(brush)


class VerticalLine(QGraphicsLineItem):
	"""
	This is a subclass of QGraphicsLineItem that draws a vertical line.
	The constructor expects the coordinates of the initial point as well as the
	length and width of the line. The color is set through the brush that we
	supply to the constructor.
	"""
	
	def __init__(self, x0, y0, length, width, brush, parent=None):
		QGraphicsLineItem.__init__(self, parent)

		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)
		self.setLine(x0, y0, x0, y0+length)


class HorizontalLine(QGraphicsLineItem):
	"""
	This is a subclass of QGraphicsLineItem that draws a horizontal line.
	The constructor expects the coordinates of the initial point as well as the
	length and width of the line. The color is set through the brush that we
	supply to the constructor.
	"""
	
	def __init__(self, x0, y0, length, width, brush, parent=None):
		QGraphicsLineItem.__init__(self, parent)
		
		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)
		self.setLine(x0, y0, x0+length, y0)


class Circle(QGraphicsEllipseItem):
	"""
	This is a subclass of the more general ellipse shape. We should supply
	the coordinates of the center as well as the radius and the width of the
	line used to draw the circle. The color is set through the brush.
	"""
	
	def __init__(self, x0, y0, radius, width, brush, parent=None):
		QGraphicsEllipseItem.__init__(self, parent)
		
		self.pen = QPen()
		self.pen.setBrush(brush)
		self.pen.setWidth(width)
		
		self.setPen(self.pen)		
		self.setRect(x0-radius, y0-radius, 2*radius, 2*radius)


def main():
	app = QApplication(sys.argv)
	mainWin = MainWindow()
	mainWin.show()
	app.exec_()

main()
